# _*_ coding utf-8 _*_
"""
@File : BlockChain_1.py
@Author: yxwang
@Date : 2021/1/12
@Desc :
"""

import os, subprocess, time, signal
import gym
from gym import error, spaces
from gym import utils
from gym.utils import seeding
import numpy as np

from geo_coordination import geographical_coordination
from Theil import *
from geo_distribution import *

'''
动作空间: 4维度，分别是验证节点选择，算法选择，区块大小， 时间间隔
状态空间: 单位时间间隔区块大小， 权益分布， 物理节点位置， 物理节点计算能力 
收益范围: 对不同的动作状态有不同的收益
'''

# 未给定值时的默认值
AREA_OF_NODES = (1000, 1000)  # 将节点散落的区域假定为规整矩形
N_OF_NODES = 30  # 所有的IIoT节点，N，其中包括block_producer
N_OF_BLOCK_PRODUCER = 21  # 常选择21，block_producer的个数，暂时将生产者数量固定
AVERAGE_TRANSACTION_SIZE = 200  # 200B
# ---------------------------------------------------------
# 权益及算力的分配应当服从高斯分布
# STAKE_OF_NODES = (10, 50)  # 对不同的节点权益分配,范围(0, 1)
STAKE_OF_NODES = (0, 1)  # 对不同的节点权益分配,范围(0, 1)
POWER_OF_NODES = (0, 1)
# ---------------------------------------------------------
COMPUTING_RESOURCE_OF_NODE = np.ones(N_OF_NODES, ) * 10  # 暂定为10~30GHz，(generating MACs和verifying MACs)
BLOCK_SIZE_LIMIT = 8 * 1024  # 最大区块的大小限制设定为8M，为统一单位定为B
MAX_BLOCK_INTERVAL = 10  # 最大区块打包间隔时间10s
ETA_S = 0.2
ETA_L = 0.3  # 基尼系数中对去中心化程度的最大限制设定为0.2与0.3
BATCH_SIZE = 3  # 如在PBFT算法中，一个massage中，primary节点处理的request


class BlockChainEnv(gym.Env):
    reward_range = (-float('inf'), float('inf'))  # 收益范围
    def __init__(self, n_of_nodes=N_OF_NODES, area_of_nodes=AREA_OF_NODES,
                 average_transaction_size=AVERAGE_TRANSACTION_SIZE,
                 n_of_block_producer=N_OF_BLOCK_PRODUCER, stake_of_nodes=STAKE_OF_NODES,
                 computing_resource_of_node=COMPUTING_RESOURCE_OF_NODE,
                 block_size_limit=BLOCK_SIZE_LIMIT, max_block_interval=MAX_BLOCK_INTERVAL,
                 eta_s=ETA_S, eta_l=ETA_L, batch_size=BATCH_SIZE):
        # 定义环境
        self.n_of_nodes = n_of_nodes
        self.area_of_nodes = area_of_nodes
        self.average_transaction_size = average_transaction_size
        self.n_of_block_producer = n_of_block_producer
        self.stake_of_nodes = stake_of_nodes
        self.computing_resource_of_node = computing_resource_of_node
        self.block_size_limit = block_size_limit
        self.max_block_interval = max_block_interval
        self.eta_s = eta_s
        self.eta_l = eta_l
        self.batch_size = batch_size
        # -----------------------------------------------------------------------------------------------------
        self.observation_space = spaces.Dict(
            {
                'Tl_norm': spaces.Box(low=0, high=1, shape=(1,)),
                'location_of_producers': spaces.Box(low=-AREA_OF_NODES[0] / 2, high=AREA_OF_NODES[1] / 2,
                                                    shape=(self.n_of_block_producer, 2)),
                'throughout': spaces.Box(low=0, high=np.inf, shape=(1,)),
                # 'transmission_rate': spaces.Box(low=10, high=100, shape=(self.n_of_nodes,self.n_of_nodes)),
                'transmission_rate': spaces.Box(low=10, high=100, shape=(1,)),
            })
        # -----------------------------------------------------------------------------------------------------
        # 动作空间包括打包节点，共识算法，区块大小，区块间隔
        self.action_space = spaces.Dict({
            # 对所有的节点进行判断，值为1的节点是block_producer
            # 选择共识算法，将不同的共识算法记做0,1,2,3,4...
            # 对于动作空间的选择，连续与离散的区别
            # 重写MultiBinaryFixed，从n个节点中随机选取M个节点作为生产者
            'no_block_producer': spaces.MultiBinaryFixed(n_of_nodes, n_of_block_producer),
            'no_consensus_algorithm': spaces.Discrete(3),
            'block_size': spaces.Box(low=0, high=BLOCK_SIZE_LIMIT, shape=(1,)),
            'block_interval': spaces.Box(low=0, high=MAX_BLOCK_INTERVAL, shape=(1,))
        })
        # -----------------------------------------------------------------------------------------------------

        self.seed()
        self.states = []
        self.actions = []
        # 在observation里，有矩阵的运算，如何在DDPG里处理, self.state类型是orderedDict
        self.state = self.observation_space.sample()
        self.producer_X = []
        self.producer_Y = []
        self.concate = []
        # 利用泊松分布随机化区域内的节点，节点总数为n_of_nodes
        self.instance_of_geo_coor = geographical_coordination(-self.area_of_nodes[0] / 2, self.area_of_nodes[0] / 2,
                                                              -self.area_of_nodes[1] / 2, self.area_of_nodes[1] / 2,
                                                              self.n_of_nodes).geographical_coordinates()

    def reset(self):
        self.state = self.observation_space.sample()

        s = []
        s += (list(v.reshape(-1)) for k, v in self.state.items())
        s_array = []

        for i in range(4):
            for j in range(len(s[i])):
                if i == 1:
                    s_array.append(s[i][j])
                elif i == 2:
                    if (s[i][j] < 0):
                        s_array.append(s[i][j] / AREA_OF_NODES[0] / 2)
                    else:
                        s_array.append(s[i][j] / AREA_OF_NODES[1] / 2)
                elif i == 3:
                    s_array.append(s[i][j])
                else:
                    s_array.append(s[i][j] - 10 / 90)
        # for i in range(4):
        #     for j in range(len(s[i])):
        #         s_array.append(s[i][j])
        print(s_array)
        # return np.array(self.state)
        return np.array(s_array)

    def step(self, action):
        """
        在完成一幕之后，需要调用reset()重置环境状态：一幕定义为：(1)应用场景改变 (2)某个场景在一段时间内达到较优的效率
        接收到动作之后，返回一个元组，包括（观察到的状态， 收益， 是否结束， 信息）
        Arg:
            action: 通过智能体给出动作，动作的选取是采用soft-epsilon，还是添加noise
        Returns:
            observation (object): 智能体观察到的当前状态
            reward (float) : 根据之前的动作所得到的的收益
            done (bool): 是否达到终止状态
            info (dict): 包括一些辅助信息
        """
        # 初始化状态
        # done作为一个episode结束的标志
        # 传递的action参数是通过神经网络得到的输出，由于最后一层使用sigmoid function使得输出在(0,1)之间
        l = []
        keyList = ['no_block_producer','no_consensus_algorithm','block_size','block_interval']
        valueList = []

        # for i in range(len(action)):
        #     if i < self.n_of_nodes:
        #         l.append(1 if action[i]>0.5 else 0)
        #         continue
        action_dict = {}
        for i in range(len(action)):
            if(i < self.n_of_nodes):
                l.append(1 if action[i]>0.5 else 0)
                if(i == self.n_of_nodes-1):
                    valueList.append(np.array(l))
                continue
            valueList.append(np.array(action[i]))

        for i in range(len(keyList)):
            action_dict[keyList[i]] = valueList[i]
        print(action_dict)

        action_dict['no_consensus_algorithm'] = int(action_dict['no_consensus_algorithm']*3)
        action_dict['block_size'] = action_dict['block_size'] * BLOCK_SIZE_LIMIT if action_dict['block_size'] != 0 else (action_dict['block_size'] + 0.01)* BLOCK_SIZE_LIMIT
        action_dict['block_interval'] = action_dict['block_interval'] * MAX_BLOCK_INTERVAL if action_dict['block_interval'] != 0 else (action_dict['block_interval'] + 0.01) * MAX_BLOCK_INTERVAL

        # s应该为array
        s = self.state
        s_ = []
        reward = 0
        done = False
        # 将当前状态的值赋给参数
        Tl_norm, location, throughout, transmission_rate = (s[k] for k in s.keys())

        # 通过动作状态中的block_producer的选择，使得Tl_G，Tl_L， Tl_C(权利、地理、算力)改变，
        # 同时computing_capacity、transmission_rate、共识算法的选择、区块大小的选择与传输时间有关
        # 动态适应节点的变化，对从较少节点的联盟链共识算法到节点较多的公链共识算法有较好鲁棒性
        no_block_producer = np.count_nonzero(action['no_block_producer'])
        self.index_of_producer = np.argwhere(np.array(action['no_block_producer']) == 1)

        # 生产者节点的数量与坐标
        self.n_of_block_producer = no_block_producer
        # ?????????????????? 如何保证每次生产者变化 最终收敛??????????????????????????????
        self.producer_X = self.instance_of_geo_coor.xxRetained[self.index_of_producer]
        self.producer_Y = self.instance_of_geo_coor.yyRetained[self.index_of_producer]

        self.concate = np.asarray(
            [[self.producer_X[i][0], self.producer_Y[i][0]] for i in range(self.n_of_block_producer)], dtype=np.float32)

        '''
        根据选择的block_producer的个数，及相关因素，重新分配stake
        自动调节block_producer的个数
        '''
        coef_of_security = self.get_security_coef(action)

        '''
        根据节点位置及block_producer的改变，transmition_rate改变(10~100Mbps)
        是通过模拟，还是通过计算？
        '''
        transmission_rate = self.get_transmission_rate()

        '''
        计算能力，事先对不同的节点赋予不同的计算能力
        '''
        computing_capacity_of_IIoT_nodes, T_final = self.get_computing_capacity(action, transmission_rate)

        # 利用泰尔系数计算去中心化程度 C表示算力 G表示权益 lambda0表示地理
        C = np.asarray(computing_capacity_of_IIoT_nodes)
        C = C[C != 0]
        K = self.n_of_block_producer
        Theil_instance = Theil(K)
        Tl_norm_C = Theil_instance.get_Theil_Computation(C)

        G = np.random.randint(10, 50, K)
        Tl_norm_G = Theil_instance.get_Theil_Stake(G)

        # ????????????划分区域个数??????????? 需要与前端结合
        area = self.area_of_nodes[0] * self.area_of_nodes[1] / 1000000
        lambda0, n = geo_distribution(area, self.area_of_nodes[0], self.area_of_nodes[1]).get_lambda0(self.concate)
        Tl_norm_L = Theil_instance.get_Theil_Lambda(lambda0, n)
        Tl_norm = Theil_instance.get_Theil_norm(action['no_consensus_algorithm'], Tl_norm_C, Tl_norm_G, Tl_norm_L)

        # 单位B/s，计算使用最终达到一致性时间
        throughout = np.floor(action['block_size'] / self.average_transaction_size) * 1000 / (
                    action['block_interval'] + T_final)

        s_ = {
            'throughout': throughout,
            'Tl_norm': Tl_norm,
            'transmission_rate': transmission_rate,
            'location_of_producers': location
        }

        self.state = s_

        # reward的计算
        if not done:
            if Tl_norm_L < 1 and Tl_norm_G < 1 and Tl_norm_C and Tl_norm < 1:
                reward = throughout
            else:
                reward = -100
        else:
            reward = 0
        # done = bool(
        #     # TODO 判定结束的条件
        # )

        return s_, reward, done, {}

    def get_security_coef(self, action):
        # 共识算法安全性能系数，系数越大越安全
        if action['no_consensus_algorithm'] == 0:
            return 0.7
        elif action['no_consensus_algorithm'] == 1 or action['no_consensus_algorithm'] == 3:
            return 0.2
        elif action['no_consensus_algorithm'] == 2:
            return 0.7

    def get_computing_capacity(self, action, transmission_rate):
        # 判定不同的算法中，所需要的计算能力,通过MAC验证：
        # client的作用为收集交易ID，生成Merkel Tree，打包成区块并发送至primary
        # primary的作用为收到来自客户端交易并将交易转发给其他副本节点
        # 暂时不计信道中的传播时间，仅计算传输时间，使用5类双绞线(100Mbps)/超5类双绞线(1000Mbps)
        if action['no_consensus_algorithm'] != -1:
            # 编号为0的算法是PBFT
            # 首先选择client和primary
            # Alpha:computing_cost_of_verifying_signitures   Beta:computing_cost_of_generating/verifying_MACs
            M = self.batch_size
            Alpha = 2  # MHz
            Beta = 1  # MHz
            f = np.floor((self.n_of_block_producer - 1) / 3)
            K = self.n_of_block_producer
            iop = self.index_of_producer.reshape(-1)
            '''
                for each batch with bath size M, the primary node needs to verify M signatures 
                and complete 2M + 4 (K − 1) MAC operations

                the replica node ; (i != c;p) needs to very M signature and complete M + 4 (K − 1) MAC operations.

                Considering the worst case(f<np.floor((k-1)/3)), the computational load per batch for the primary node
                and the replica node are O[primary] = M*Alpha+[2M + 4 (K + f − 1)]*Beta;(The computing cost for verifying signatures and
                generating/verifying MACs,Alpha; Beta, defined as 2MHz/1MHz)
                and O[replica]= M * Alpha + [M + 4 *(K + f − 1)]*Beta 
            '''
            # 视图编号
            v = 1

            # Tau: 时间限制
            Tau = 100  # ms

            # arg_primary = v mod |N|, v:视图编号，|N|:节点个数， arg_primary:主节点编号
            index = np.mod(v, K)
            arg_primary = iop[index]
            # arg_primary = np.mod(v, K)

            while True:
                # arg_client = np.random.choice(iop.reshape(-1))
                arg_client = np.random.choice(iop)
                if arg_primary != arg_client:
                    break

            cl_0 = np.zeros((self.n_of_nodes,))
            # print(type(cl_0))

            cl_0[iop] = M * Alpha + (M + 4 * (K + f - 1)) * Beta
            cl_0[arg_primary] = M * Alpha + (2 * M + 4 * (K + f - 1)) * Beta
            cl_0[arg_client] = M * Alpha + (K + f - 1) * Beta

            # verification的时间，验证所需要的计算能力/节点的计算能力
            Tv = 1 / M * max(cl_0[i] / self.computing_resource_of_node[i] for i in iop if i != arg_client)

            # Td = 1 / M * (min(M * action['block_size'] / transmission_rate[arg_client][arg_primary], Tau) +
            #               min(max(M*action['block_size']/[transmission_rate[arg_primary][i] for i in iop if i not in[arg_primary, arg_client]]), Tau) +
            #               min(max(M*action['block_size']/[transmission_rate[i][j] for i in iop for j in iop if i != arg_client and j != arg_client and i != j]), Tau)+
            #               min(max(M*action['block_size']/[transmission_rate[i][j] for i in iop for j in iop if i != j]), Tau) +
            #               min(max(M*action['block_size']/[transmission_rate[i][arg_client] for i in iop if i != arg_client]), Tau))

            Td1 = min(M * action['block_size'] * 8 * 0.001 / transmission_rate[arg_client][arg_primary], Tau)
            Td2 = min(max(M * action['block_size'] * 8 * 0.001 / [transmission_rate[arg_primary][i] for i in iop if
                                                                  i not in [arg_primary, arg_client]]), Tau)
            Td3 = min(max(M * action['block_size'] * 8 * 0.001 / [transmission_rate[i][j] for i in iop for j in iop if
                                                                  i != arg_client and j != arg_client and i != j]), Tau)
            Td4 = min(max(
                M * action['block_size'] * 8 * 0.001 / [transmission_rate[i][j] for i in iop for j in iop if i != j]),
                      Tau)
            Td5 = min(max(M * action['block_size'] * 8 * 0.001 / [transmission_rate[i][arg_client] for i in iop if
                                                                  i != arg_client]), Tau)
            Td = 1 / M * (Td1 + Td2 + Td3 + Td4 + Td5)

            return cl_0, Td + Tv


        elif action['no_consensus_algorithm'] == 1:
            # 编号为1的算法是Zyzzyva的fast case
            M = self.batch_size
            Alpha = 2  # MHz
            Beta = 1  # MHz
            K = self.n_of_block_producer
            iop = self.index_of_producer.reshape(-1)
            '''
            For Zyaayva algorithm, there exist two cases: (1)fast case: consider there is no faluty nodes, the primary node
            needs to verify M signiture and complete 2M+K−1 MAC operations while replica node(i != c;p) requires to
            verify M signiture and complete M+1 MAC operations for each batch.

            the computational load per batch for the primary node and the replica node are O[primary]= M*Alpha+(2M+K−1)*Beta
            and O[replica]= M*Alpha+(M+1)*Beta
            '''

            # 视图编号
            v = 1

            # Tau: 时间限制
            Tau = 100  # ms

            # arg_primary = v mod |N|, v:视图编号，|N|:节点个数， arg_primary:主节点编号
            index = np.mod(v, K)
            arg_primary = iop[index]

            while True:
                arg_client = np.random.choice(iop)
                if arg_primary != arg_client:
                    break

            cl_1 = np.zeros((self.n_of_nodes,))

            # 根据client,primary,replica节点需要产生和验证的MAC，计算节点所需的计算能力
            cl_1[iop] = M * Alpha + (M + 1) * Beta
            cl_1[arg_primary] = M * Alpha + (2 * M + K - 1) * Beta
            cl_1[arg_client] = M * Alpha + (K - 1) * Beta

            Tv = 1 / M * max(cl_1[i] / self.computing_resource_of_node[i] for i in iop if i != arg_client)
            Td1 = min(M * action['block_size'] * 8 * 0.001 / transmission_rate[arg_client][arg_primary], Tau)
            Td2 = min(max(M * action['block_size'] * 8 * 0.001 / transmission_rate[arg_primary][i] for i in iop
                          if i not in [arg_primary, arg_client]), Tau)
            Td3 = min(max((M * action['block_size'] * 8 * 0.001 / transmission_rate[i][arg_client] for i in iop
                           if i not in [arg_client])), Tau)
            Td = 1 / M * (Td1 + Td2 + Td3)

            return cl_1, Td + Tv

        elif action['no_consensus_algorithm'] == 2:
            # 编号为2的算法是Zyzzyva的two-phase case
            # 首先选择client和primary
            M = self.batch_size
            Alpha = 2  # MHz
            Beta = 1  # MHz
            f = np.floor((self.n_of_block_producer - 1) / 3)
            K = self.n_of_block_producer
            iop = self.index_of_producer.reshape(-1)
            '''
            For Zyaayva algorithm two-phase case, accepting faluty nodes of f, the computational load per batch for
            the primary node and the replica node are O[primary]= M*Alpha+(4M+K+f−1)*Beta
            and O[replica]= M*Alpha+(3M+1)*Beta
            '''
            # 视图编号
            v = 1

            # Tau: 时间限制
            Tau = 100  # ms

            # tr: first case与two phase之间的间隔
            tr = 5  # ms

            # arg_primary = v mod |N|, v:视图编号，|N|:节点个数， arg_primary:主节点编号
            # arg_primary = np.mod(v, K)
            index = np.mod(v, K)
            arg_primary = iop[index]

            while True:
                arg_client = np.random.choice(iop)
                if arg_primary != arg_client:
                    break

            cl_2 = np.zeros((self.n_of_nodes,))

            # 根据client,primary,replica节点需要产生和验证的MAC，计算节点所需的计算能力
            cl_2[iop] = M * Alpha + (3 * M + 1) * Beta
            cl_2[arg_primary] = M * Alpha + (4 * M + K + f - 1) * Beta
            cl_2[arg_client] = K * M * Alpha + (2 * K + f - 2) * Beta

            Tv = 1 / M * max(
                cl_2[i] / self.computing_resource_of_node[i] for i in iop if i != arg_client)

            Td1 = min(M * action['block_size'] * 8 * 0.001 / transmission_rate[arg_client][arg_primary], Tau)
            Td2 = min(max(M * action['block_size'] * 8 * 0.001 / transmission_rate[arg_primary][i] for i in iop
                          if i not in [arg_primary, arg_client]), Tau)

            Td3 = min(max((M * action['block_size'] * 8 * 0.001 / transmission_rate[i][arg_client] for i in iop if
                           i not in [arg_client])), Tau)

            Td4 = min(max((M * action['block_size'] * 8 * 0.001 / transmission_rate[arg_client][i] for i in iop if
                           i not in [arg_client])), Tau)

            Td5 = min(max((M * action['block_size'] * 8 * 0.001 / transmission_rate[i][arg_client] for i in iop if
                           i not in [arg_client])), Tau)

            Td = 1 / M * (Td1 + Td2 + Td3 + tr + Td4 + Td5)

            return cl_2, Td + Tv

        elif action['no_consensus_algorithm'] == 3:
            # 编号为3的算法是Quorum
            # 没有primary节点
            Alpha = 2  # MHz
            Beta = 1  # MHz
            K = self.n_of_block_producer
            iop = self.index_of_producer.reshape(-1)
            '''
            The robustness of Quorum is poorest among these three protocols since it fails to reach consensus
            once there’s any faulty replica (f = 0), The consensus process only involves two phases – Request and Reply.
            Note that there’s no primary replica and batching doesn’t work for Quorum.

            The computational load per request for the replica k=1,2,...K(k!=c) O[replica] = Alpha + 2Beta
            '''

            arg_client = np.random.choice(iop)

            cl_3 = np.zeros((self.n_of_nodes,))

            # 计算节点所需的计算能力
            # for i in iop:
            #     cl_3[i] = Alpha + 2 * Beta
            cl_3[iop] = Alpha + 2 * Beta

            Tv = max(cl_3[i] / self.computing_resource_of_node[i] for i in iop if i != arg_client)
            # Td = min(max(action['block_size'] / transmission_rate[arg_client][i] for i in iop if i != arg_client), Tau) +\
            #     min(max(action['block_size'] / transmission_rate[i][arg_client] for i in iop), Tau)

            Td1 = min(max(
                action['block_size'] * 8 * 0.001 / transmission_rate[arg_client][i] for i in iop if i != arg_client),
                      Tau)
            Td2 = min(max(action['block_size'] * 8 * 0.001 / transmission_rate[i][arg_client] for i in iop), Tau)
            Td = Td1 + Td2
            return cl_3, Td + Tv

        elif action['no_consensus_algorithm'] == 4:
            # 编号为4的算法是Aardvark
            # 首先选择client和primary
            M = self.batch_size
            Alpha = 2  # MHz
            Beta = 1  # MHz
            f = np.floor((self.n_of_block_producer - 1) / 3)
            K = self.n_of_block_producer
            iop = self.index_of_producer.reshape(-1)

            # 视图编号
            v = 1

            # Tau: 时间限制
            Tau = 100  # ms

            # arg_primary = v mod |N|, v:视图编号，|N|:节点个数， arg_primary:主节点编号
            # arg_primary = np.mod(v, K)
            index = np.mod(v, K)
            arg_primary = iop[index]

            while True:
                arg_client = np.random.choice(iop)
                if arg_primary != arg_client:
                    break

            cl_4 = np.zeros((self.n_of_nodes,))

            # 根据client, primary, replica节点需要产生和验证的MAC，计算节点所需的计算能力
            cl_4[iop] = M * Alpha + (M + 4 * (K + f - 1)) * Beta
            cl_4[arg_primary] = M * Alpha + (2 * M + 4 * (K + f - 1)) * Beta
            cl_4[arg_client] = M * Alpha + (K + f - 1) * Beta

            Tv = 1 / M * max(
                cl_4[i] / self.computing_resource_of_node[i] for i in iop if i != arg_client)
            Td1 = min(M * action['block_size'] * 8 * 0.001 / transmission_rate[arg_client][arg_primary], Tau)
            Td2 = min(max(M * action['block_size'] * 8 * 0.001 / transmission_rate[arg_primary][i] for i in iop if
                          i not in [arg_primary, arg_client]), Tau)
            Td3 = min(max((M * action['block_size'] * 8 * 0.001 / transmission_rate[i][j] for i in iop for j in iop if
                           i != arg_client and j != arg_client and i != j)), Tau)
            Td4 = min(max(M * action['block_size'] * 8 * 0.001 / transmission_rate[i][j] for i in iop for j in iop if
                          i != j), Tau)
            Td5 = min(max(M * action['block_size'] * 8 * 0.001 / transmission_rate[i][arg_client] for i in iop), Tau)
            Td = 1 / M * (Td1 + Td2 + Td3 + Td4 + Td5)

            return cl_4, Td + Tv

        # elif action['no_consensus_algorithm'] == 5:
        #     # 编号为5的算法是RBFT
        #     # 首先选择client和primary
        #     M = self.batch_size
        #     Alpha = 2  # MHz
        #     Beta = 1  # MHz
        #     f = np.floor((self.n_of_block_producer - 1) / 3)
        #     K = self.n_of_block_producer
        #     iop = self.index_of_producer.reshape(-1)
        #
        #     # arg_primary = v mod |N|, v:视图编号，|N|:节点个数， arg_primary:主节点编号
        #     arg_primary = np.random.choice(iop)
        #
        #     # 根据client, primary, replica节点需要产生和验证的MAC，计算节点所需的计算能力
        #     for i in iop:
        #         if i == arg_primary:
        #             self.computing_resource_of_node[arg_primary] = M * Alpha + (2 * M + 4*(K + f - 1)) * Beta
        #             continue
        #         # replica nodes
        #         self.computing_resource_of_node[i] = M * Alpha + (M + 4*(K + f - 1)) * Beta

        # elif action['no_consensus_algorithm'] == 6:
        #     # TODO: 非联盟链的共识算法，一般来说是在节点数较多的情况下进行切换
        #     pass
        else:
            pass

    def get_transmission_rate(self):
        base_time_latency = 10  # 利用虚拟机或其他方法模拟节点时间通讯的基本延迟
        # 直接令传输速率为固定值,单位设置为Mbps
        transmission = [[0 for i in range(self.n_of_nodes)] for j in range(self.n_of_nodes)]
        # index_of_producer = self.index_of_producer.reshape(-1)
        # for x in index_of_producer:
        #     for y in index_of_producer:
        #         if y!=x:
        #             transmission[x][y] = base_time_latency * np.sqrt(
        #                 np.power(self.instance_of_geo_coor.xxRetained[x]-self.instance_of_geo_coor.xxRetained[y],2)+
        #                 np.power(self.instance_of_geo_coor.yyRetained[x]-self.instance_of_geo_coor.yyRetained[y],2))
        index_of_producer = self.index_of_producer.reshape(-1)
        for x in index_of_producer:
            for y in index_of_producer:
                if y != x:
                    transmission[x][y] = 100
        return transmission

    def close(self):
        pass

    def seed(self, seed=None):
        self.np_random, seed = seeding.np_random(seed)
        return [seed]

    def sample(self):
        pass
